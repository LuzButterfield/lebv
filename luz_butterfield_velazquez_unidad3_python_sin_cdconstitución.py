# -*- coding: utf-8 -*-
"""Luz BUTTERFIELD VELAZQUEZ - Unidad3_Python_Sin_CdConstitución.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12rMbul54CJAF6_XeUFisWS4wNL1dJc1G

# ***PROGRAMACIÓN PYTHON***

---

# **UNIDAD 3 - Funciones, cadenas y listas.**

---
## Funciones.

Como todos los lenguajes de programación, en Python es posible definir funciones propias para ejecutar código personalizado. Para definirlas es necesario utilizar la palabra reservada `def`. La sintaxis de cualquier función en Python es la siguiente:

```
def nombre_funcion(parámetros):
    código
    return retorno
```

Toda función contiene un **nombre, parámetros** y **valor de retorno** (opcional). Al igual que las variables, no es necesario definir el tipo de dato que retornará la función. Al igual que sucede con las estructuras de slección y los ciclos, ya que se va a comenzar con un nuevo bloque de código, es necsario dejar una identación para que el interpreta reconozca el código subsecuente como parte del cuerpo de la función. El valor de retorno es opcional, sí la función no devuelve nada, se omite.

Como ejemplo se va a desarrollar una función sin argumentos que nada más salude al usuario:
"""



"""Una llamada a la función, es igual que en otro lenguajes de programación, escribiendo su nombre y los argumentos correspondientes:"""



"""## **Pase de argumentos.**

Todas las funciones en Python tienen la capacidad de recibir parámetros, que son las variables locales con las que operará la función.

En Python, a las funciones se les puede pasar un argumento, argumentos posicionados, por nombre, predetermnados y de longitud variable.

### ***Parámetro sencillo.***

Modificar la función anterior pero agregando como argumento el nombre de a quien saludará:

QUE ES LA SOBRECARGA DE FUNCIONES, SE UTILIZAN VARIAS FUNCIONES A LA VEZ.
"""

def saludar(nombre):
  print("hola",nombre)

saludar("Luz Elena")

"""En otros lenguajes de programación existe la sobrecarga de funciones ¿Recuerdas qué significa ese término? Consiste en tener varias funciones con el mismo nombre cuya única diferencia es la cantidad y opcionalmente el tipo de argumentos que recibe. Por ejemplo en C++ es válido tener:

```
#Código C++
int suma(int n1, int n2);
int suma(float n1, float n2, float n3);
```

En el ejemplo anterior, el compilador se encargará de llamar a la función correspondiente cuando sea llamada en base a los valores pasados.

¿Qué pasa en Python si intentas llamar las dos funciones difinidas anteriormente?

PARA HACERLO EN PYTHON, 
"""

saludar("luz Elena")
saludar()

"""Eso es debido a que Python no soporta la sobrecarga de funciones, sin embargo proporciona los otros medios de pase de argumentos que servirán para asemejar la funcionalidad descrita, con la ventaja de que el código será más simple y sencillo de leer.

### ***Parámetros por posición.***

Los parámetros por posición son aquellos que en la firma de la función tiene un orden y que al ser invocada, los datos que se le pasen como argumentos se almacenarán en las variables correspondientes de acuerdo a su posición. Además se exige que la función sea llamada exactamente con la misma cantidad de parámetros con la que fue declarada.

EL PASE DE PARAMETROS ES UNA BUENA OPCION PARA MNADAR INFORMACIÓN. 
paso de parametros por nombre
"""

def resta(n1, n2):
  return n1- n2

res=resta(2,3)
print(res)



"""### ***Parámetros por nombre.***

En Python es posible utilizar el nombre del parámetro para asignarle un valor, usando este modo, es válido ignorar la posición de los argumentos:
"""

print(resta (n2 = 2, n1 = 3))

"""### ***Parámetros con valor predeterminado.***

En la firma de una función, es posible declarar un parámetro que tenga un valor de manera predeterminada, esto permitirá que dicho argumento sea opcional al momento de invocar la función, el interprete detectará que no le fue asignado algún valor y por tanto utilizará el valor predeterminado:
"""

def  resta(n1, n2, n3=0):
  return n1-n2-n3

print(resta(10,5))
print(resta(10,5,1))
print(resta(n3=10, n1=4, n2=1))

"""### ***Parámetros de longitud variable***.

Python permite que el número de argumentos que se le pase a una función pueda ser variable, es decir que la función pueda recibir n cantidad de datos como argumentos. Para indicar al interprete que el argumento será de longitud variable, es necesario anteponer un asterisco (*) antes del nombre del parámetro. AL hacerlo, automáticamente el interprete covierte el parámetro en una tupla:
"""

def resta(*nums):
  print(type(nums))

  res=0
  for n in nums:
    res -=n
  
  return res

print(resta())
print(resta(1))
print(resta(2,3))
print(resta(4,5,6,7,8,9))
print(resta(4,5,6,7,805,999))

"""Si agregamos dos asteriscos (**), es posible pasarle como parámetro los datos en forma de *clave = valor*, o bien, diorectamente un diccionario. Para obtener los datos, se utilizará ```items()```:"""

def resta(**nums):
  print(type(nums))

  res=0
  for clave, valor in nums.items():
    res-=valor

  return res

print(resta(entero = 10, flotante=5.5, imaginario= 3+8))

calc =  {"ent" :6, "float": 56.3, "img": 2.7} 
print(resta(**calc8))

"""# **Operaciones con cadenas y formateo**.

Como se mencionó en lecciones anteriores, las cadenas son secuencias de caracteres y son inmutables. no tiene un tamaño en memoria predeterminado y para declararlas, es necesario colocar el texto entre comillas dobles o sencillas.

Dentro de ellas es posible usar secuencias de escape pero también existen las conocidas como *raw strings* que ignoran dichas secuencias:
"""

from traitlets.traitlets import Type
print("NUEVO TEMA DE CADENA")
cadena1 = "Esto es una cadena"
cadena2 = "Esto también es una cadena"

print(cadena1)
print(cadena2)

cadenaMultilinea= '''Esto es una cadena de varias líneas
con tabulares de saltos de
línea '''
print(cadenaMultilinea,type(cadenaMultilinea))

cadena3 = ' '
print(cadena3, type(cadena3))

print("SEGMENTACIÓN DE CADENAS: ")
print(cadena1[5:11])
print(cadena1[3:])
print(cadena1[7:])
print(cadena1[-8:-1])
print(cadena1[0:18:1])
print(cadena1[0:18:2])
print(cadena1[0:18:3])

cadena4=(cadena1+" ")*5
print(cadena4)

nuevoTema=("TIPOS MUTABLES E INMUTABLES")


x=10
print(nuevoTema)
print("Identidad", id(x))
print("Tipo", type(x))
print("valor",x)

lista1=[1,2,3,4,5]
lista2=list("6789")

print(lista1)
print(lista2)
lista3=[1,"Hola", 3.14, [1,2,3]]
print(lista3)

"""Las cadens se pueden concatenar usando el operador "+", sin importar la cantidad:"""

lista1=[1,2,3,4,5]
lista2=list("6789")

print(lista1)
print(lista2)
lista3=lista1+lista2
print(lista3)

"""Con la función `format()` es posible agregar variables a una cadena, acomodándolas por posición o mediante su nombre:"""

lista1=[1,2,3,4,5]
lista2=list("6789")

print(lista1)
print(lista2)
lista3=[1,"Hola", 3.14, [1,2,3]]
print(lista3)

"""Las `f-strings()` permiten utilizar variables dentro de las cadenas como los ejemplos anteriores pero además agrega la posibilidad de realizar operaciones dentro de ellas e incluso invocar a una función:"""

course = 'Python'
platform = 'Platzi'

print(f"El nuevo curso de {course} en {platform} está increíble")

"""Con las cadenas es posible realizar:

*   Multiplicación de una cadena por un número entero.
*   Buscar si una cadena está contenida en otra.
*   Convertir una cadena a su valor numérico y viceversa (este último caso sólo funciona con caráctres).
*   Obtener el tamaño de una cadena.
*   Conversión de clases.
*   Indizarlas.
*   Segmentar cadenas.




"""

mensaje2a = 'Hola ' * 3
mensaje2b = 'Mundo'
print(mensaje2a + mensaje2b)

"""Las cadenas en Python son una clase muy poderosa en Python y la cual dispone de numerosos métodos que incrementan la flexibilidad, uso y operaciones con este tipo de objeto. Para conocer los métodos e incluso más formas de formateo de cadenas, consulta la [documentación oficial](https://docs.python.org/3/library/stdtypes.html#string-methods).

# **Operaciones con listas.**

Algunas propiedades de las listas:

*   Son ordenadas.
*   Pueden contener distintos tipos de datos.
*   Son iterables.
*   Son mutables.
*   Son dinámicas.

Para acceder a los elementos de una lista, se utilizan los corchetes `[n]`, donde `n` es el índice del elemento al que queremos acceder. El tamaño de la lista va desde 0 hasta n - 1.
"""

mensaje5 = "Hola Mundo"
mensaje5a = mensaje5.find("Mundo")
print(mensaje5a)

"""Se puede recorres la lista del final hacía el principio utlizando numeros negativos, donde -1 es el úlitmo elemento, -2, el penúlitmo, etc.:"""

mensaje6 = "Hola Mundo"
mensaje6a = mensaje6.find("ardilla")
print(mensaje6a)

"""Para modificar un elemento de la lista, tan sólo es necesario asignar el nuevo valor al elemento correspondiente:"""

mensaje4 = 'hola' + ' ' + 'mundo'
print(len(mensaje4))

"""Para eliminar un elemento de la lista mediante su índice, se utiliza `del`:"""



"""Si se desea acceder a los elementos que forman parte de una lista que está dentro de una lista, se agregan tantos corchetes con su respectivo índice como listas internas se tengan:"""

lista=[1,2]
num = lista[1]
print (num)

"""También con las listas, utilizando la sintaxis de `[n:m]` se pueden obtener sublistas y modificar multiples valores. Además las listas soportan el operador `+` que añade una lista a la otra y por otro lado, con una lista es posible asignar sus *n* elementos a n* *cantidad de variables independientes:"""



"""También es posible iterar sobre las listas utilizando ciclos para acceder a sus elementos, acompañarlos con su índice e incluso iterar varias listas al mismo tiempo:"""



"""**NOTA:** La función `zip()` crea un objeto *Zip* el cual es un iterador de tuplas donde cada elemento que se le pase como argumento, es emparejado con el del otro parámetro respetando posición en la que se encuentran.

Además de las operaciones básicas anteriores, las listas tiene sus propios métodos que también realizan operaciones sobre ellas:


*  list.append(x)
*  list.extend(iterable)
*  list.insert(i, x)
*  list.remove(x)
*  list.pop([i])
*  list.clear()
*  list.index(x[, start[, end]])
*  list.count(x)
*  list.sort(*, key=None, reverse=False)
*  list.reverse()
*  list.copy()

Para conocer la manera correcta de utilzar los métodos anteriores, revisa la  [documentación oficial de Python sobre listas.](https://docs.python.org/3/tutorial/datastructures.html)

## ***Ejercicio:***

Después de haber revisado la documentación oficial, en el siguiente apartado añade ejemplos (al menos uno por cada método), del uso de dichas funciones, puedes utlilzar las listas creadas aterioremente o bien definir las propias, sé claro y documenta el código que realices:
"""

frutas = ['apple', 'banana', 'cherry']
frutas.append("orange")
print(frutas)

frutas = ['apple', 'banana', 'cherry']
cars = ['Ford', 'BMW', 'Volvo']
frutas.extend(cars)

print(frutas)

frutas = ['apple', 'banana', 'cherry']

frutas.insert(1, "orange")
print (frutas)

frutas = ['apple', 'banana', 'cherry']

frutas.remove("banana")
frutas = ['apple', 'banana', 'cherry']

frutas.remove("banana")
print(frutas)

frutas = ['apple', 'banana', 'cherry']

frutas.pop(1)

print(frutas)

#Añade ejemplos del uso de los métodos de las listas.

"""***ANOTA Y COMPARTE TUS REFLEXIONES DE LOS TEMAS VISTOS ANTERIORMENTE:***
______________________________________________________________________________https://www.w3schools.com/python/trypython.asp?filename=demo_ref_list_extend en esta página eambién existe muchos ejemplos
_______________________________________________________________________________
_______________________________________________________________________________
_______________________________________________________________________________
_______________________________________________________________________________
"""